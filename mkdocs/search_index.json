{
    "docs": [
        {
            "location": "/", 
            "text": "Easy, powerful and ultrafast ODM for PHP7 build on top of the \nnew mongodb driver\n.\n\n\n\n\nMongolid supports both \nActiveRecord\n and \nDataMapper\n patterns. \nYou choose! (:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction\n\n\nMongolid ODM (Object Document Mapper) provides a beautiful, simple implementation for working with MongoDB. Each database collection can have a corresponding \nModel\n which is used to interact with that collection.\n\n\n\n\nNote:\n If you are working with Laravel, take a look at \nmongolid-laravel repository\n.", 
            "title": "Home"
        }, 
        {
            "location": "/#introduction", 
            "text": "Mongolid ODM (Object Document Mapper) provides a beautiful, simple implementation for working with MongoDB. Each database collection can have a corresponding  Model  which is used to interact with that collection.   Note:  If you are working with Laravel, take a look at  mongolid-laravel repository .", 
            "title": "Introduction"
        }, 
        {
            "location": "/basics/", 
            "text": "Installation\n\n\nYou can install library through Composer:\n\n\n$ composer require leroy-merlin-br/mongolid\n\n\n\n\nRequirements\n\n\n\n\nPHP\n7\n\n\nMongoDB Driver\n\n\n\n\nSetup\n\n\nIf you are not using Laravel, you should initialize the Mongolid connection pool and container manually.\nThe minimalistic way of doing it is to use \nMongolid\\Manager\n:\n\n\n?php\nrequire 'vendor/autoload.php';\n\nuse Mongolid\\Manager;\nuse Mongolid\\Connection;\n\n$manager = new Manager(new Connection('mongodb://localhost:27017'));\n\n\n\n\nNow you are ready to create your own models :smile:\n\n\nBasic Usage\n\n\n\n\nNote:\n Mongolid does support \nDataMapper\n pattern\n, but in order to understand it let\ns begin with the \nActiveRecord\n pattern:\n\n\n\n\nclass Post extends Mongolid\\ActiveRecord {}\n\n\n\n\nNote that we did not tell Mongolid which collection to use for our \nPost\n model. So, in this case, Mongolid \nwill not save the model into the database\n. This can be used for models that represents objects that will be embedded within another object and will not have their own collection.\n\n\nYou may specify a collection by defining a \ncollection\n property on your model:\n\n\nclass Post extends ActiveRecord {\n\n    protected $collection = 'posts';\n\n}\n\n\n\n\nMongolid will also assume each collection has a primary key attribute named \n_id\n, since MongoDB requires an \n_id\n for every single document. The \n_id\n attribute can be of any type. The default type for this attribute is \nObjectId\n. \nLearn more about the MongoId\n.\n\n\n\n\nNote:\n Mongolid will automatically convert strings in ObjectId format (For example: \n4af9f23d8ead0e1d32000000\n) to \nObjectId\n when querying or saving an object.\n\n\n\n\nOnce a model is defined, you are ready to start retrieving and creating documents in your collection.\n\n\nRetrieving All Models\n\n\n    $posts = Post::all();\n\n\n\n\nRetrieving A Document By Primary Key\n\n\n    $post = Post::first('4af9f23d8ead0e1d32000000');\n\n    // or\n\n    $post = Post::first(new MongoDB\\BSON\\ObjectID('4af9f23d8ead0e1d32000000'));\n\n\n\n\nRetrieving One Document By attribute\n\n\n    $user = Post::first(['title'=\n'How Monglid saved the day']);\n\n\n\n\nRetrieving Many Documents By attribute\n\n\n    $posts = Post::where(['category'=\n'coding']);\n\n\n\n\nQuerying Using Mongolid Models\n\n\n    $posts = Post::where(['votes'=\n['$gt'=\n100]])-\nlimit(10); // Mongolid\\Cursor\\Cursor\n\n    foreach ($posts as $post)\n    {\n        var_dump($post-\ntitle);\n    }\n\n\n\n\nMongolid Count\n\n\n    $count = Post::where(['votes'=\n['$gt'=\n100]])-\ncount(); // integer\n\n\n\n\nPretty easy right?\n\n\nMonglid Cursor\n\n\nIn MongoDB, a cursor is used to iterate through the results of a database query. For example, to query the database and see all results:\n\n\n    $cursor = User::where(['kind'=\n'visitor']);\n\n\n\n\nIn the above example, the $cursor variable will be a \nMongolid\\Cursor\\Cursor\n.\n\n\nThe Mongolid\ns \nCursor\n wraps the original \nMongoDB\\Driver\\Cursor\n object of the new MongoDB Driver in a way that you can build queries in a more fluent and easy way. Also the Mongolid\ns \nCursor\n will make sure to return the instances of your model instead of stdClass or arrays.\n\n\n\n\nNote:\n The \nCursor class of the new driver\n is not as user friendly as the old one. Mongolid\ns cursor also make it as easy to use as the old one.\n\n\n\n\nThe \nMongolid\\Cursor\\Cursor\n object has alot of methods that helps you to iterate, refine and get information. For example:\n\n\n    $cursor = User::where(['kind'=\n'visitor']);\n\n    // Sorts the results by given fields. In the example bellow, it sorts by username DESC\n    $cursor-\nsort(['username'=\n-1]);\n\n    // Limits the number of results returned.\n    $cursor-\nlimit(10);\n\n    // Skips a number of results. Good for pagination\n    $cursor-\nskip(20);\n\n    // Checks if the cursor is reading a valid result.\n    $cursor-\nvalid();\n\n    // Returns the first result\n    $cursor-\nfirst();\n\n\n\n\nYou can also chain some methods:\n\n\n    $page = 2;\n\n    // In order to display 10 results per page\n    $cursor = User::all()-\nsort(['_id'=\n1])-\nskip(10 * $page)-\nlimit(10);\n\n    // Then iterate through it\n    foreach($cursor as $user) {\n        // do something\n    }\n\n\n\n\nInsert, Update, Delete\n\n\nTo create a new document in the database from a model, simply create a new model instance and call the \nsave\n method.\n\n\nSaving A New Model\n\n\n    $post = new Post;\n\n    $post-\ntitle = 'Foo bar john doe';\n\n    $post-\nsave();\n\n\n\n\n\n\nNote:\n Typically, your Mongolid models will have auto-generated \n_id\n keys. However, if you wish to specify your own keys, set the \n_id\n attribute.\n\n\n\n\nTo update a model, you may retrieve it, change an attribute, and use the \nsave\n method:\n\n\nUpdating A Retrieved Model\n\n\n    $post = Post::first('4af9f23d8ead0e1d32000000');\n\n    $post-\nsubject = 'technology';\n\n    $post-\nsave();\n\n\n\n\nTo delete a model, simply call the \ndelete\n method on the instance:\n\n\nDeleting An Existing Model\n\n\n    $post = Post::first('4af9f23d8ead0e1d32000000');\n\n    $post-\ndelete();\n\n\n\n\nMass Assignment\n\n\nIf you are extending \nMongolid\\ActiveRecord\n you can set an array of attributes to the model using the \nfill\n method. These attributes are then assigned to the model via mass-assignment. This is convenient; however, can be a \nserious\n security concern when blindly passing user input into a model. If user input is blindly passed into a model, the user is free to modify \nany\n and \nall\n of the model\ns attributes. By default, all attributes are fillable.\n\n\nMongolid\\ActiveRecord\n (and \nMongolid\\Model\\Attributes\n trait) will use the \nfillable\n or \nguarded\n properties on your model.\n\n\nThe \nfillable\n property specifies which attributes should be mass-assignable. This can be set at the class or instance level.\n\n\nDefining Fillable Attributes On A Model\n\n\n    class Post extends ActiveRecord {\n\n        protected $fillable = ['title', 'category', 'body'];\n\n    }\n\n\n\n\nIn this example, only the three listed attributes will be mass-assignable.\n\n\nThe inverse of \nfillable\n is \nguarded\n, and serves as a \nblack-list\n instead of a \nwhite-list\n:\n\n\nDefining Guarded Attributes On A Model\n\n\n    class Post extends ActiveRecord {\n\n        protected $guarded = ['_id', 'votes'];\n\n    }\n\n\n\n\nIn the example above, the \nid\n and \nvotes\n attributes may \nnot\n be mass assigned. All other attributes will be mass assignable.\n\n\nYou can mass assign attributes using the \nfill\n method:\n\n\n    $post = new Post;\n    $post-\nfill(['title' =\n 'Bacon']);\n\n\n\n\nConverting To Arrays / JSON\n\n\nWhen building JSON APIs, you may often need to convert your models to arrays or JSON. So, Mongolid includes methods for doing so. To convert a model and its loaded relationship to an array, you may use the \ntoArray\n method:\n\n\nConverting A Model To An Array\n\n\n    $user = User::with('roles')-\nfirst();\n\n    return $user-\ntoArray();\n\n\n\n\nNote that \ncursors\n can be converted to array too:\n\n\n    return User::all()-\ntoArray();\n\n\n\n\nTo convert a model to JSON, you may use the \ntoJson\n method:\n\n\nConverting A Model To JSON\n\n\n    return User::find(1)-\ntoJson();", 
            "title": "Basics"
        }, 
        {
            "location": "/basics/#installation", 
            "text": "You can install library through Composer:  $ composer require leroy-merlin-br/mongolid", 
            "title": "Installation"
        }, 
        {
            "location": "/basics/#requirements", 
            "text": "PHP 7  MongoDB Driver", 
            "title": "Requirements"
        }, 
        {
            "location": "/basics/#setup", 
            "text": "If you are not using Laravel, you should initialize the Mongolid connection pool and container manually.\nThe minimalistic way of doing it is to use  Mongolid\\Manager :  ?php\nrequire 'vendor/autoload.php';\n\nuse Mongolid\\Manager;\nuse Mongolid\\Connection;\n\n$manager = new Manager(new Connection('mongodb://localhost:27017'));  Now you are ready to create your own models :smile:", 
            "title": "Setup"
        }, 
        {
            "location": "/basics/#basic-usage", 
            "text": "Note:  Mongolid does support  DataMapper  pattern , but in order to understand it let s begin with the  ActiveRecord  pattern:   class Post extends Mongolid\\ActiveRecord {}  Note that we did not tell Mongolid which collection to use for our  Post  model. So, in this case, Mongolid  will not save the model into the database . This can be used for models that represents objects that will be embedded within another object and will not have their own collection.  You may specify a collection by defining a  collection  property on your model:  class Post extends ActiveRecord {\n\n    protected $collection = 'posts';\n\n}  Mongolid will also assume each collection has a primary key attribute named  _id , since MongoDB requires an  _id  for every single document. The  _id  attribute can be of any type. The default type for this attribute is  ObjectId .  Learn more about the MongoId .   Note:  Mongolid will automatically convert strings in ObjectId format (For example:  4af9f23d8ead0e1d32000000 ) to  ObjectId  when querying or saving an object.   Once a model is defined, you are ready to start retrieving and creating documents in your collection.  Retrieving All Models      $posts = Post::all();  Retrieving A Document By Primary Key      $post = Post::first('4af9f23d8ead0e1d32000000');\n\n    // or\n\n    $post = Post::first(new MongoDB\\BSON\\ObjectID('4af9f23d8ead0e1d32000000'));  Retrieving One Document By attribute      $user = Post::first(['title'= 'How Monglid saved the day']);  Retrieving Many Documents By attribute      $posts = Post::where(['category'= 'coding']);  Querying Using Mongolid Models      $posts = Post::where(['votes'= ['$gt'= 100]])- limit(10); // Mongolid\\Cursor\\Cursor\n\n    foreach ($posts as $post)\n    {\n        var_dump($post- title);\n    }  Mongolid Count      $count = Post::where(['votes'= ['$gt'= 100]])- count(); // integer  Pretty easy right?", 
            "title": "Basic Usage"
        }, 
        {
            "location": "/basics/#monglid-cursor", 
            "text": "In MongoDB, a cursor is used to iterate through the results of a database query. For example, to query the database and see all results:      $cursor = User::where(['kind'= 'visitor']);  In the above example, the $cursor variable will be a  Mongolid\\Cursor\\Cursor .  The Mongolid s  Cursor  wraps the original  MongoDB\\Driver\\Cursor  object of the new MongoDB Driver in a way that you can build queries in a more fluent and easy way. Also the Mongolid s  Cursor  will make sure to return the instances of your model instead of stdClass or arrays.   Note:  The  Cursor class of the new driver  is not as user friendly as the old one. Mongolid s cursor also make it as easy to use as the old one.   The  Mongolid\\Cursor\\Cursor  object has alot of methods that helps you to iterate, refine and get information. For example:      $cursor = User::where(['kind'= 'visitor']);\n\n    // Sorts the results by given fields. In the example bellow, it sorts by username DESC\n    $cursor- sort(['username'= -1]);\n\n    // Limits the number of results returned.\n    $cursor- limit(10);\n\n    // Skips a number of results. Good for pagination\n    $cursor- skip(20);\n\n    // Checks if the cursor is reading a valid result.\n    $cursor- valid();\n\n    // Returns the first result\n    $cursor- first();  You can also chain some methods:      $page = 2;\n\n    // In order to display 10 results per page\n    $cursor = User::all()- sort(['_id'= 1])- skip(10 * $page)- limit(10);\n\n    // Then iterate through it\n    foreach($cursor as $user) {\n        // do something\n    }", 
            "title": "Monglid Cursor"
        }, 
        {
            "location": "/basics/#insert-update-delete", 
            "text": "To create a new document in the database from a model, simply create a new model instance and call the  save  method.  Saving A New Model      $post = new Post;\n\n    $post- title = 'Foo bar john doe';\n\n    $post- save();   Note:  Typically, your Mongolid models will have auto-generated  _id  keys. However, if you wish to specify your own keys, set the  _id  attribute.   To update a model, you may retrieve it, change an attribute, and use the  save  method:  Updating A Retrieved Model      $post = Post::first('4af9f23d8ead0e1d32000000');\n\n    $post- subject = 'technology';\n\n    $post- save();  To delete a model, simply call the  delete  method on the instance:  Deleting An Existing Model      $post = Post::first('4af9f23d8ead0e1d32000000');\n\n    $post- delete();", 
            "title": "Insert, Update, Delete"
        }, 
        {
            "location": "/basics/#mass-assignment", 
            "text": "If you are extending  Mongolid\\ActiveRecord  you can set an array of attributes to the model using the  fill  method. These attributes are then assigned to the model via mass-assignment. This is convenient; however, can be a  serious  security concern when blindly passing user input into a model. If user input is blindly passed into a model, the user is free to modify  any  and  all  of the model s attributes. By default, all attributes are fillable.  Mongolid\\ActiveRecord  (and  Mongolid\\Model\\Attributes  trait) will use the  fillable  or  guarded  properties on your model.  The  fillable  property specifies which attributes should be mass-assignable. This can be set at the class or instance level.  Defining Fillable Attributes On A Model      class Post extends ActiveRecord {\n\n        protected $fillable = ['title', 'category', 'body'];\n\n    }  In this example, only the three listed attributes will be mass-assignable.  The inverse of  fillable  is  guarded , and serves as a  black-list  instead of a  white-list :  Defining Guarded Attributes On A Model      class Post extends ActiveRecord {\n\n        protected $guarded = ['_id', 'votes'];\n\n    }  In the example above, the  id  and  votes  attributes may  not  be mass assigned. All other attributes will be mass assignable.  You can mass assign attributes using the  fill  method:      $post = new Post;\n    $post- fill(['title' =  'Bacon']);", 
            "title": "Mass Assignment"
        }, 
        {
            "location": "/basics/#converting-to-arrays-json", 
            "text": "When building JSON APIs, you may often need to convert your models to arrays or JSON. So, Mongolid includes methods for doing so. To convert a model and its loaded relationship to an array, you may use the  toArray  method:  Converting A Model To An Array      $user = User::with('roles')- first();\n\n    return $user- toArray();  Note that  cursors  can be converted to array too:      return User::all()- toArray();  To convert a model to JSON, you may use the  toJson  method:  Converting A Model To JSON      return User::find(1)- toJson();", 
            "title": "Converting To Arrays / JSON"
        }, 
        {
            "location": "/relationships/", 
            "text": "Relationships\n\n\nOf course, your database collections are probably related to one another. For example, a blog post may have many comments, or an order could be related to the user who placed it. Mongolid makes managing and working with these relationships easy. MongoDB and Mongolid in short supports four types of relationships:\n\n\n\n\nEmbeds One\n\n\nEmbeds Many\n\n\nReferences One\n\n\nReferences Many\n\n\n\n\n\n\nNote:\n MongoDB \nrelationships doesn\nt works like in a Relational database\n. In MongoDB, data modeling decisions involve determining how to structure the documents to model the data effectively. The primary decision is whether to embed or to use references. See \nMongoDB - Data Modeling Decisions\n for more information on this subject.\n\n\n\n\nEmbeds One\n\n\nRead \nMongoDB - Embedded Data Models\n to learn more how to take advantage of document embedding.\n\n\nA Embeds One relationship is a very basic relation. For example, a \nUser\n model might have one \nPhone\n. We can define this relation in Mongolid:\n\n\nDefining A Embeds One Relation\n\n\n    // models/Person.php\n    class Person extends ActiveRecord {\n\n        // This model is saved in the collection people\n        protected $collection = 'people';\n\n        // Method that will be used to access the phone\n        public function phone()\n        {\n            return $this-\nembedsOne('Phone', 'phone');\n        }\n\n    }\n\n    // models/Phone.php\n    class Phone extends ActiveRecord {\n\n        // This model will be embedded only\n        protected $collection = null;\n\n        public function getFullPhone()\n        {\n            return '+' . $this-\nregionCode . $this-\nnumber;\n        }\n\n    }\n\n\n\n\nThe first argument passed to the \nembedsOne\n method is the name of the related model. The second argument is in what attribute that object will be embedded. Once the relationship is defined, we may retrieve it using:\n\n\n    $phone = User::find('4af9f23d8ead0e1d32000000')-\nphone();\n\n\n\n\nWhich will translate to:\n\n\n\n\nQuery for the user with the \n_id\n \n4af9f23d8ead0e1d32000000\n\n\nInstantiate a \nPhone\n object with the attributes found in \nphone\n attribute of the user\n\n\nReturn that object\n\n\n\n\nIn order to embed a document to be used in a Embeds One relationship, simply fo the following:\n\n\n    // The object that will be embeded\n    $phoneObj = new Phone;\n    $phoneObj-\nregionCode = '55';\n    $phoneObj-\nnumber = '1532323232';\n\n    // The object that will contain the phone\n    $user = User::first('4af9f23d8ead0e1d32000000');\n\n    // This method will embed the $phoneObj into the phone attribute of the user\n    $user-\nembed('phone', $phoneObj);\n\n    // This is an alias to the method called above.\n    $user-\nembedToPhone($phoneObj);\n\n    // Not recomended, but also works\n    $user-\nphone = $phoneObj-\nattributes;\n\n    // Or (not recomended)\n    $user-\nphone = $phoneObj-\ntoArray();\n\n    // Or even (not recomended)\n    $user-\nphone = [\n        'regionCode' =\n $phoneObj-\nregionCode,\n        'number' =\n $phoneObj-\nnumber\n    ];\n\n    $user-\nsave();\n\n    // Now we can retrieve the object by calling\n    $user-\nphone(); // Will return a Phone object similar to $phoneObj\n\n\n\n\n\n\nNote:\n When using Mongolid models you will need to call the \nsave()\n method after embeding or attaching objects. The changes will only persists after you call the \nsave()\n method.\n\n\n\n\nIt\ns recomended that you don\nt embed your models by setting the attribute directly. The \nembed\n method will include an \n_id\n to identify your embeded document and allow the usage of \nunembed\n and \nembed\n to update models.\n\n\n    $user-\nembed('phone', $phoneObj); // Now, $phoneObj have an _id\n\n    $phoneObj-\nregionCode = 77; // Update the region code\n\n    $user-\nembed($phoneObj); // Will update\n\n\n\n\nEmbeds many\n\n\nAn example of a Embeds Many relation is a blog post that \nhas many\n comments. We can model this relation like so:\n\n\n    // models/Post.php\n    class Post extends ActiveRecord {\n\n        protected $collection = 'posts';\n\n        public function comments()\n        {\n            return $this-\nembedsMany('Comment', 'comments');\n        }\n\n    }\n\n    // models/Comment.php\n    class Comment extends ActiveRecord {\n\n        // This model will be embedded only\n        protected $collection = null;\n\n    }\n\n\n\n\nNow we can access the post\ns comments \nEmbeddedCursor\n through the comments method:\n\n\n    $comments = Post::find('4af9f23d8ead0e1d32000000')-\ncomments();\n\n\n\n\nNow you can iterate and perform cursor operations in the \nEmbeddedCursor\n that is retrieved\n\n\n    foreach($comments-\nlimit(10) as $comment)\n    {\n        // do something\n    }\n\n\n\n\nIn order to embed a document to be used in a Embeds Many relationship, you should use the \nembed\n method or the alias \nembedTo\nAttribute\n:\n\n\n    $commentA = new Comment;\n    $commentA-\ncontent = 'Cool feature bro!';\n\n    $commentB = new Comment;\n    $commentB-\ncontent = 'Awesome!';\n\n    $post = Post::first('4af9f23d8ead0e1d32000000');\n\n    // Both ways work\n    $post-\nembedToComments($commentA);\n    $post-\nembed('Comments', $commentB);\n\n    $post-\nsave();\n\n\n\n\n\n\nNote:\n When using Mongolid models you will need to call the \nsave()\n method after embeding or attaching objects. The changes will only persists after you call the \nsave()\n method.\n\n\n\n\nThe \nembed\n method will include an \n_id\n to identify your embeded document and allow the usage of \nembed\n and \nunembed\n to update or delete embeded documents:\n\n\n    $commentB-\ncontent = \nPretty awesome!\n;\n\n    $post-\nunembed($commentA); // Removes 'Cool feature bro!'\n    $post-\nembed($commentB);   // Updates 'Awesome' to 'Pretty awesome'\n\n\n\n\nReferences One\n\n\nIn Mongolid a reference is made by storing the \n_id\n of the referenced object. \n\n\nReferencing provides more flexibility than embedding; however, to resolve the references, client-side applications must issue follow-up queries. In other words, using references requires more roundtrips to the server.\n\n\nIn general, use references when embedding would result in duplication of data and would not provide sufficient read performance advantages to outweigh the implications of the duplication. Read \nMongoDB - Relationships with Document References\n to learn more how to take advantage of referencing in MongoDB.\n\n\n\n\nNote:\n MongoDB \nrelationships doesn\nt works like in a Relational database\n. In MongoDB, data modeling decisions involve determining how to structure the documents to model the data effectively. If you try to create references between documents like you would do in a relational database you will end up with \nn+1 problem\n and poor performance.\n\n\n\n\nDefining A References One Relation\n\n\n    // models/Post.php\n    class Post extends ActiveRecord {\n\n        protected $collection = 'posts';\n\n        public function author()\n        {\n            return $this-\nreferencesOne('User', 'author');\n        }\n\n    }\n\n    // models/User.php\n    class User extends ActiveRecord {\n\n        protected $collection = 'users';\n\n    }\n\n\n\n\nThe first argument passed to the \nreferencesOne\n method is the name of the related model, the second argument is the attribute where the referenced model \n_id\n will be stored. Once the relationship is defined, we may retrieve it using the following method:\n\n\n    $user = Post::find('4af9f23d8ead0e1d32000000')-\nauthor();\n\n\n\n\nThis statement will perform the following:\n\n\n\n\nQuery for the post with the \n_id\n \n4af9f23d8ead0e1d32000000\n\n\nQuery for the user with the \n_id\n equals to the \nauthor\n attribute of the post\n\n\nReturn that object\n\n\n\n\nIn order to set a reference to a document, simply set the attribute used in the relationship to the reference\ns \n_id\n or use the attach method or it\ns alias. For example:\n\n\n    // The object that will be embeded\n    $userObj = new User;\n    $userObj-\nname = 'John';\n    $userObj-\nsave() // This will populates the $userObj-\n_id\n\n    // The object that will contain the user\n    $post = Post::first('4af9f23d8ead0e1d32000000');\n\n    // This method will attach the $phoneObj _id into the phone attribute of the user\n    $post-\nattach('author', $userObj);\n\n    // This is an alias to the method called above.\n    $post-\nattachToAuthor($userObj);\n\n    // This will will also work\n    $post-\nauthor = $userObj-\n_id;\n\n    $post-\nsave();\n\n    $post-\nauthor(); // Will return a User object\n\n\n\n\n\n\nNote:\n When using Mongolid models you will need to call the \nsave()\n method after embedding or attaching objects. The changes will only persists after you call the \nsave()\n method.\n\n\n\n\nReferences Many\n\n\nIn Mongolid a \nReferences Many\n is made by storing the \n_id\ns of the referenced objects.\n\n\nReferencing provides more flexibility than embedding; however, to resolve the references, client-side applications must issue follow-up queries. In other words, using references requires more roundtrips to the server.\n\n\nIn general, use references when embedding would result in duplication of data and would not provide sufficient read performance advantages to outweigh the implications of the duplication. Read \nMongoDB - Relationships with Document References\n to learn more how to take advantage of referencing in MongoDB.\n\n\nDefining A References Many Relation\n\n\n    // models/User.php\n    class User extends ActiveRecord {\n\n        protected $collection = 'users';\n\n        public function questions()\n        {\n            return $this-\nreferencesMany('Question', 'questions');\n        }\n\n    }\n\n    // models/Question.php\n    class Question extends ActiveRecord {\n\n        protected $collection = 'questions';\n\n    }\n\n\n\n\nThe first argument passed to the \nreferencesMany\n method is the name of the related model, the second argument is the attribute where the \n_id\ns will be stored. Once the relationship is defined, we may retrieve it using the following method:\n\n\n    $posts = User::find('4af9f23d8ead0e1d32000000')-\nposts();\n\n\n\n\nThis statement will perform the following:\n\n\n\n\nQuery for the user with the \n_id\n \n4af9f23d8ead0e1d32000000\n\n\nQuery for all the posts with the \n_id\n in the user\ns \nposts\n attribute\n\n\nReturn the \nMongolid\\Cursor\\Cursor\n with the related posts\n\n\n\n\nIn order to set a reference to a document use the attach method or it\ns alias. For example:\n\n\n    $postA = new Post;\n    $postA-\ntitle = 'Nice post';\n\n    $postB = new Post;\n    $postB-\ntitle = 'Nicer post';\n\n    $user = User::first('4af9f23d8ead0e1d32000000');\n\n    // Both ways work\n    $user-\nattachToPosts($postA);\n    $user-\nattach('posts', $postB);\n\n    $user-\nsave();\n\n\n\n\n\n\nNote:\n When using Mongolid models you will need to call the \nsave()\n method after embedding or attaching objects. The changes will only persists after you call the \nsave()\n method.\n\n\n\n\nYou can use \ndettach\n method with the referenced object or it\ns \n_id\n in order to remove a single reference.", 
            "title": "Relationships"
        }, 
        {
            "location": "/relationships/#relationships", 
            "text": "Of course, your database collections are probably related to one another. For example, a blog post may have many comments, or an order could be related to the user who placed it. Mongolid makes managing and working with these relationships easy. MongoDB and Mongolid in short supports four types of relationships:   Embeds One  Embeds Many  References One  References Many    Note:  MongoDB  relationships doesn t works like in a Relational database . In MongoDB, data modeling decisions involve determining how to structure the documents to model the data effectively. The primary decision is whether to embed or to use references. See  MongoDB - Data Modeling Decisions  for more information on this subject.", 
            "title": "Relationships"
        }, 
        {
            "location": "/relationships/#embeds-one", 
            "text": "Read  MongoDB - Embedded Data Models  to learn more how to take advantage of document embedding.  A Embeds One relationship is a very basic relation. For example, a  User  model might have one  Phone . We can define this relation in Mongolid:  Defining A Embeds One Relation      // models/Person.php\n    class Person extends ActiveRecord {\n\n        // This model is saved in the collection people\n        protected $collection = 'people';\n\n        // Method that will be used to access the phone\n        public function phone()\n        {\n            return $this- embedsOne('Phone', 'phone');\n        }\n\n    }\n\n    // models/Phone.php\n    class Phone extends ActiveRecord {\n\n        // This model will be embedded only\n        protected $collection = null;\n\n        public function getFullPhone()\n        {\n            return '+' . $this- regionCode . $this- number;\n        }\n\n    }  The first argument passed to the  embedsOne  method is the name of the related model. The second argument is in what attribute that object will be embedded. Once the relationship is defined, we may retrieve it using:      $phone = User::find('4af9f23d8ead0e1d32000000')- phone();  Which will translate to:   Query for the user with the  _id   4af9f23d8ead0e1d32000000  Instantiate a  Phone  object with the attributes found in  phone  attribute of the user  Return that object   In order to embed a document to be used in a Embeds One relationship, simply fo the following:      // The object that will be embeded\n    $phoneObj = new Phone;\n    $phoneObj- regionCode = '55';\n    $phoneObj- number = '1532323232';\n\n    // The object that will contain the phone\n    $user = User::first('4af9f23d8ead0e1d32000000');\n\n    // This method will embed the $phoneObj into the phone attribute of the user\n    $user- embed('phone', $phoneObj);\n\n    // This is an alias to the method called above.\n    $user- embedToPhone($phoneObj);\n\n    // Not recomended, but also works\n    $user- phone = $phoneObj- attributes;\n\n    // Or (not recomended)\n    $user- phone = $phoneObj- toArray();\n\n    // Or even (not recomended)\n    $user- phone = [\n        'regionCode' =  $phoneObj- regionCode,\n        'number' =  $phoneObj- number\n    ];\n\n    $user- save();\n\n    // Now we can retrieve the object by calling\n    $user- phone(); // Will return a Phone object similar to $phoneObj   Note:  When using Mongolid models you will need to call the  save()  method after embeding or attaching objects. The changes will only persists after you call the  save()  method.   It s recomended that you don t embed your models by setting the attribute directly. The  embed  method will include an  _id  to identify your embeded document and allow the usage of  unembed  and  embed  to update models.      $user- embed('phone', $phoneObj); // Now, $phoneObj have an _id\n\n    $phoneObj- regionCode = 77; // Update the region code\n\n    $user- embed($phoneObj); // Will update", 
            "title": "Embeds One"
        }, 
        {
            "location": "/relationships/#embeds-many", 
            "text": "An example of a Embeds Many relation is a blog post that  has many  comments. We can model this relation like so:      // models/Post.php\n    class Post extends ActiveRecord {\n\n        protected $collection = 'posts';\n\n        public function comments()\n        {\n            return $this- embedsMany('Comment', 'comments');\n        }\n\n    }\n\n    // models/Comment.php\n    class Comment extends ActiveRecord {\n\n        // This model will be embedded only\n        protected $collection = null;\n\n    }  Now we can access the post s comments  EmbeddedCursor  through the comments method:      $comments = Post::find('4af9f23d8ead0e1d32000000')- comments();  Now you can iterate and perform cursor operations in the  EmbeddedCursor  that is retrieved      foreach($comments- limit(10) as $comment)\n    {\n        // do something\n    }  In order to embed a document to be used in a Embeds Many relationship, you should use the  embed  method or the alias  embedTo Attribute :      $commentA = new Comment;\n    $commentA- content = 'Cool feature bro!';\n\n    $commentB = new Comment;\n    $commentB- content = 'Awesome!';\n\n    $post = Post::first('4af9f23d8ead0e1d32000000');\n\n    // Both ways work\n    $post- embedToComments($commentA);\n    $post- embed('Comments', $commentB);\n\n    $post- save();   Note:  When using Mongolid models you will need to call the  save()  method after embeding or attaching objects. The changes will only persists after you call the  save()  method.   The  embed  method will include an  _id  to identify your embeded document and allow the usage of  embed  and  unembed  to update or delete embeded documents:      $commentB- content =  Pretty awesome! ;\n\n    $post- unembed($commentA); // Removes 'Cool feature bro!'\n    $post- embed($commentB);   // Updates 'Awesome' to 'Pretty awesome'", 
            "title": "Embeds many"
        }, 
        {
            "location": "/relationships/#references-one", 
            "text": "In Mongolid a reference is made by storing the  _id  of the referenced object.   Referencing provides more flexibility than embedding; however, to resolve the references, client-side applications must issue follow-up queries. In other words, using references requires more roundtrips to the server.  In general, use references when embedding would result in duplication of data and would not provide sufficient read performance advantages to outweigh the implications of the duplication. Read  MongoDB - Relationships with Document References  to learn more how to take advantage of referencing in MongoDB.   Note:  MongoDB  relationships doesn t works like in a Relational database . In MongoDB, data modeling decisions involve determining how to structure the documents to model the data effectively. If you try to create references between documents like you would do in a relational database you will end up with  n+1 problem  and poor performance.   Defining A References One Relation      // models/Post.php\n    class Post extends ActiveRecord {\n\n        protected $collection = 'posts';\n\n        public function author()\n        {\n            return $this- referencesOne('User', 'author');\n        }\n\n    }\n\n    // models/User.php\n    class User extends ActiveRecord {\n\n        protected $collection = 'users';\n\n    }  The first argument passed to the  referencesOne  method is the name of the related model, the second argument is the attribute where the referenced model  _id  will be stored. Once the relationship is defined, we may retrieve it using the following method:      $user = Post::find('4af9f23d8ead0e1d32000000')- author();  This statement will perform the following:   Query for the post with the  _id   4af9f23d8ead0e1d32000000  Query for the user with the  _id  equals to the  author  attribute of the post  Return that object   In order to set a reference to a document, simply set the attribute used in the relationship to the reference s  _id  or use the attach method or it s alias. For example:      // The object that will be embeded\n    $userObj = new User;\n    $userObj- name = 'John';\n    $userObj- save() // This will populates the $userObj- _id\n\n    // The object that will contain the user\n    $post = Post::first('4af9f23d8ead0e1d32000000');\n\n    // This method will attach the $phoneObj _id into the phone attribute of the user\n    $post- attach('author', $userObj);\n\n    // This is an alias to the method called above.\n    $post- attachToAuthor($userObj);\n\n    // This will will also work\n    $post- author = $userObj- _id;\n\n    $post- save();\n\n    $post- author(); // Will return a User object   Note:  When using Mongolid models you will need to call the  save()  method after embedding or attaching objects. The changes will only persists after you call the  save()  method.", 
            "title": "References One"
        }, 
        {
            "location": "/relationships/#references-many", 
            "text": "In Mongolid a  References Many  is made by storing the  _id s of the referenced objects.  Referencing provides more flexibility than embedding; however, to resolve the references, client-side applications must issue follow-up queries. In other words, using references requires more roundtrips to the server.  In general, use references when embedding would result in duplication of data and would not provide sufficient read performance advantages to outweigh the implications of the duplication. Read  MongoDB - Relationships with Document References  to learn more how to take advantage of referencing in MongoDB.  Defining A References Many Relation      // models/User.php\n    class User extends ActiveRecord {\n\n        protected $collection = 'users';\n\n        public function questions()\n        {\n            return $this- referencesMany('Question', 'questions');\n        }\n\n    }\n\n    // models/Question.php\n    class Question extends ActiveRecord {\n\n        protected $collection = 'questions';\n\n    }  The first argument passed to the  referencesMany  method is the name of the related model, the second argument is the attribute where the  _id s will be stored. Once the relationship is defined, we may retrieve it using the following method:      $posts = User::find('4af9f23d8ead0e1d32000000')- posts();  This statement will perform the following:   Query for the user with the  _id   4af9f23d8ead0e1d32000000  Query for all the posts with the  _id  in the user s  posts  attribute  Return the  Mongolid\\Cursor\\Cursor  with the related posts   In order to set a reference to a document use the attach method or it s alias. For example:      $postA = new Post;\n    $postA- title = 'Nice post';\n\n    $postB = new Post;\n    $postB- title = 'Nicer post';\n\n    $user = User::first('4af9f23d8ead0e1d32000000');\n\n    // Both ways work\n    $user- attachToPosts($postA);\n    $user- attach('posts', $postB);\n\n    $user- save();   Note:  When using Mongolid models you will need to call the  save()  method after embedding or attaching objects. The changes will only persists after you call the  save()  method.   You can use  dettach  method with the referenced object or it s  _id  in order to remove a single reference.", 
            "title": "References Many"
        }, 
        {
            "location": "/datamapper/", 
            "text": "Introduction\n\n\nIn the \nBasics\n section you learned how to use Mongolid with the ActiveRecord pattern. The following section you explain what changes are necessary in order to use the DataMapper pattern of Mongolid.\n\n\n\n\nNote:\n To use Mongolid in the DataMapper pattern is optional. If you are looking for a more \nDomain Driven Design\n approach in your project it may be interesting to your. But if you are satisfied with what you\nve learned in the other sections, feel free to skip this one.\n\n\n\n\nBasics\n\n\nFirst of all, you have to define a \nSchema\n for your model. This is the way to map objects into the database. But don\nt worry, your schema can be dynamic, which means that you can define other fields than the specified ones.\n\n\n\n\nNote:\n The \nMongolid Schema\n is equivalent to \nmapping your objects using annotation or xml\n in other ORM or ODM libraries.\n\n\n\n\nIn order to define a schema you should extend \nMongolid\\Schema\n or \nMongolid\\DynamicSchema\n:\n\n\n?php\n\nclass ArticleSchema extends Mongolid\\Schema {\n\n    public $entityClass = 'Article';\n\n    public $collection = 'articles';\n\n    public $fields  = [\n        '_id'         =\n 'objectId',\n        'title'       =\n 'string',\n        'body'        =\n 'string',\n        'views'       =\n 'int',\n        'created_at'  =\n 'createdAtTimestamp',\n        'updated_at'  =\n 'updatedAtTimestamp'\n    ];\n}\n\n\n\n\nThen you should register your schema into the \nMongolid\\Manager\n:\n\n\n$manager-\nregisterSchema(ArticleSchema::class);\n\n\n\n\nNow you just have to create your own Domain Entity (:\n\n\nclass Article\n{\n    public $_id\n    public $title\n    public $body\n    public $views\n    public $created_at\n    public $updated_at\n\n    public function render() {\n        return \n# {$this-\ntitle}\\n\\n{$this-\nbody}\n;\n    }\n}\n\n\n\n\nInteracting with the database\n\n\nInteract with the database using the \nDataMapper\n retrieved trought the Mongolid Manager:\n\n\n$article = $manager-\ngetMapper(Article::class)\n    -\nwhere(['title' =\n 'Foobar'])-\nfirst();\n\nget_class($article) // Article\n\n$article-\nrender() // # Foobar\\n\\nBody\n$article-\ntitle = 'How Mongolid saved the day';\n\n$manager-\ngetMapper(Article::class)-\nsave($article); // true\n\n\n\n\nSchema definition\n\n\nWhen defining your schema you can eighter extend the \nMongolid\\Schema\n or \nMongolid\\DynamicSchema\n. The main difference is the \n$dynamic\n property value.\n\n\nMaking a schema dynamic\n\n\nThe \n$dynamic\n property is a \nboolean\n that tells if the schema will accept additional fields that are not specified in the $fields property. This is usefull if you doesn\nt have a strict document format or if you want to take full advantage of the \nschemaless\n nature of MongoDB.\n\n\nDefining the collection and the Domain Entity to be mapped\n\n\n$collection\n property should be the name of the collection where this kind of document is going to be saved or retrieved from. And the \n$entityClass\n should be the name of the class that will be used to represent a document of the Schema when retrieve from the database.\n\n\nDefining the fields\n\n\nThe \n$fields\n property is an array that tells how a document should look like. For each field of the document you can specify a type or how it will be \nformated\n.\n\n\nIf an scalar type is used, it will perform a cast operation in the value. Othewise the schema will use the type as the name of the method to be called.\n\n\nSee \nMongolid\\Schema::objectId\n method for example. It means that if a field type (in \n$fields\n) is defined as \n\"objectId\"\n, it will pass trought the \nMongolid\\Schema::objectId\n before being saved in the database.\n\n\nBecause of this you can create your own custom field types easily. Just create a new public method in your schema and you are ready to use it\ns name as a type definition in \n$fields\n.\n\n\nThe last option is to define a field as another schema by using the syntax \nschema.\nClass\n This represents one or more embedded documents that will be formated using another \nSchema\n class.\n\n\nDefault Schema $field types\n\n\nBy default the \nMongolid\\Schema\n contains the following types:\n\n\n\n\n\n\n\n\ntype\n\n\ndescription\n\n\n\n\n\n\n\n\n\n\nscalar type\n\n\nCasts field to \nint\n, \ninteger\n, \nbool\n, \nboolean\n, \nfloat\n, \ndouble\n, \nreal\n or \nstring\n.\n\n\n\n\n\n\nobjectId\n\n\nIf the field is not defined or if it\ns a string compatible with ObjectId notation it will be saved as an ObjectId.\n\n\n\n\n\n\nsequence\n\n\nIf value is zero or not defined a new auto-increment integer will be \ngenerated\n for that collection.\n\n\n\n\n\n\ncreatedAtTimestamp\n\n\nPrepares the field to be the datetime that the document has been created. (MongoDB\\BSON\\UTCDateTime)\n\n\n\n\n\n\nupdatedAtTimestamp\n\n\nPrepares the field to be now whenever the document is saved. (MongoDB\\BSON\\UTCDateTime)\n\n\n\n\n\n\nschema.\nClass\n\n\nDelegates the objects or arrays within the field to be mapped by another schema.\n\n\n\n\n\n\n\n\nBut you can easily create your own types. For example:\n\n\nclass MySchema extends Mongolid\\Schema\n{\n    ...\n\n    $fields = [\n        '_id' =\n 'sequence',\n        'name' =\n 'uppercaseString' // Will be processed by the method below\n    ];\n\n    public function uppercaseString(string $value) {\n        return strtoupper($value);\n    }\n}\n\n\n\n\nSchema definition for embeded documents\n\n\nBy using the \n\"schema.\nClass\n\"\n syntax you can create schemas and map Entities for embeded documents. For example, with the definition below:\n\n\nclass PostSchema extends Mongolid\\Schema\n{\n    public $entityClass = 'Post';\n    public $collection = 'posts';\n\n    $fields = [\n        '_id'      =\n 'objectId',\n        'title'    =\n 'string',\n        'body'     =\n 'string',\n        'comments' =\n 'schema.CommentSchema' // Embeds comments\n    ];\n}\n\nclass PostSchema extends Mongolid\\Schema\n{\n    public $entityClass = 'Comment';\n    public $collection = null; // Optional since all comments will be embedded\n\n    $fields = [\n        '_id'    =\n 'objectId',\n        'body'   =\n 'string',\n        'author' =\n 'string'\n    ];\n}\n\n\n\n\nThe MongoDB document\n\n\n{\n    _id: ObjectId(\n5099803df3f4948bd2f98391\n),\n    title: \nFoo bar\n,\n    body: \nLorem ipsum\n,\n    comments: [\n        {\n            _id: ObjectId(\n507f1f77bcf86cd799439011\n),\n            body: \nAwesome!\n,\n            author: \nJohn Doe\n,\n        },\n        {\n            _id: ObjectId(\n507f191e810c19729de860ea\n),\n            body: \nCool!\n,\n            author: \nAlan Turing\n,\n        }\n    ]\n}\n\n\n\n\nWill be mapped to the actual domain Entities:\n\n\n$post = $manager-\ngetMapper(Post::class)-\nfirst('5099803df3f4948bd2f98391');\n\nget_class($post) // Post\n\nget_class($post-\ncomments[1]) // Comment;\n\n$post-\ncomments[1]-\nauthor // Alan Turing\n\n// And if you are using Mongolid\\Model\\Relations trait in your entity ;)\n$post-\ncomments()-\nsort(['author' =\n 1])-\nfirst()-\nname // Alan Turing\n\n\n\n\nEntity helpers\n\n\nMongolid provides some helpers for Domain Entities in the form of traits.\n\n\nAttribute trait\n\n\nThe \nMongolid\\Model\\Attributes\n trait adds attribute getters, setters and the \nfill\n method that can be used with \n$fillable\n and \n$guarded\n properties to make sure that only the correct attributes will be set.\n\n\nBy including this trait all the entity attributes will be isolated in the \n$attributes\n property of your entity and \nmass assignment capabilities\n will be available.\n\n\nSee \nMongolid\\Model\\Attributes\n for more information.\n\n\nRelations trait\n\n\nThe \nMongolid\\Model\\Relations\n trait adds functionality for handling relations between entities. It will enable \nembedsOne\n, \nembedsMany\n, \nreferencesOne\n,\nreferencesMany\n methods and all the \nrelationship capabilities\n in the entity.\n\n\nUsing relationship methods in DataMapper pattern\n\n\nWhen using relationship methods (\nembedsMany\n for example) in DataMapper pattern, instead of referencing the \nEntity\n class you should reference the \nSchema\n class, for example:\n\n\n    ...\n    public function comments()\n    {\n        return $this-\nembedsMany('CommentSchema', 'comments');\n    }\n\n\n\n\nIn the example above Mongolid will use the \nCommentSchema\n to determine which Entity object should be used to map data of the \ncomments\n field.\n\n\nSee \nMongolid\\Model\\Relations\n for more information.", 
            "title": "DataMapper Pattern"
        }, 
        {
            "location": "/datamapper/#introduction", 
            "text": "In the  Basics  section you learned how to use Mongolid with the ActiveRecord pattern. The following section you explain what changes are necessary in order to use the DataMapper pattern of Mongolid.   Note:  To use Mongolid in the DataMapper pattern is optional. If you are looking for a more  Domain Driven Design  approach in your project it may be interesting to your. But if you are satisfied with what you ve learned in the other sections, feel free to skip this one.", 
            "title": "Introduction"
        }, 
        {
            "location": "/datamapper/#basics", 
            "text": "First of all, you have to define a  Schema  for your model. This is the way to map objects into the database. But don t worry, your schema can be dynamic, which means that you can define other fields than the specified ones.   Note:  The  Mongolid Schema  is equivalent to  mapping your objects using annotation or xml  in other ORM or ODM libraries.   In order to define a schema you should extend  Mongolid\\Schema  or  Mongolid\\DynamicSchema :  ?php\n\nclass ArticleSchema extends Mongolid\\Schema {\n\n    public $entityClass = 'Article';\n\n    public $collection = 'articles';\n\n    public $fields  = [\n        '_id'         =  'objectId',\n        'title'       =  'string',\n        'body'        =  'string',\n        'views'       =  'int',\n        'created_at'  =  'createdAtTimestamp',\n        'updated_at'  =  'updatedAtTimestamp'\n    ];\n}  Then you should register your schema into the  Mongolid\\Manager :  $manager- registerSchema(ArticleSchema::class);  Now you just have to create your own Domain Entity (:  class Article\n{\n    public $_id\n    public $title\n    public $body\n    public $views\n    public $created_at\n    public $updated_at\n\n    public function render() {\n        return  # {$this- title}\\n\\n{$this- body} ;\n    }\n}", 
            "title": "Basics"
        }, 
        {
            "location": "/datamapper/#interacting-with-the-database", 
            "text": "Interact with the database using the  DataMapper  retrieved trought the Mongolid Manager:  $article = $manager- getMapper(Article::class)\n    - where(['title' =  'Foobar'])- first();\n\nget_class($article) // Article\n\n$article- render() // # Foobar\\n\\nBody\n$article- title = 'How Mongolid saved the day';\n\n$manager- getMapper(Article::class)- save($article); // true", 
            "title": "Interacting with the database"
        }, 
        {
            "location": "/datamapper/#schema-definition", 
            "text": "When defining your schema you can eighter extend the  Mongolid\\Schema  or  Mongolid\\DynamicSchema . The main difference is the  $dynamic  property value.  Making a schema dynamic  The  $dynamic  property is a  boolean  that tells if the schema will accept additional fields that are not specified in the $fields property. This is usefull if you doesn t have a strict document format or if you want to take full advantage of the  schemaless  nature of MongoDB.  Defining the collection and the Domain Entity to be mapped  $collection  property should be the name of the collection where this kind of document is going to be saved or retrieved from. And the  $entityClass  should be the name of the class that will be used to represent a document of the Schema when retrieve from the database.  Defining the fields  The  $fields  property is an array that tells how a document should look like. For each field of the document you can specify a type or how it will be  formated .  If an scalar type is used, it will perform a cast operation in the value. Othewise the schema will use the type as the name of the method to be called.  See  Mongolid\\Schema::objectId  method for example. It means that if a field type (in  $fields ) is defined as  \"objectId\" , it will pass trought the  Mongolid\\Schema::objectId  before being saved in the database.  Because of this you can create your own custom field types easily. Just create a new public method in your schema and you are ready to use it s name as a type definition in  $fields .  The last option is to define a field as another schema by using the syntax  schema. Class  This represents one or more embedded documents that will be formated using another  Schema  class.", 
            "title": "Schema definition"
        }, 
        {
            "location": "/datamapper/#default-schema-field-types", 
            "text": "By default the  Mongolid\\Schema  contains the following types:     type  description      scalar type  Casts field to  int ,  integer ,  bool ,  boolean ,  float ,  double ,  real  or  string .    objectId  If the field is not defined or if it s a string compatible with ObjectId notation it will be saved as an ObjectId.    sequence  If value is zero or not defined a new auto-increment integer will be  generated  for that collection.    createdAtTimestamp  Prepares the field to be the datetime that the document has been created. (MongoDB\\BSON\\UTCDateTime)    updatedAtTimestamp  Prepares the field to be now whenever the document is saved. (MongoDB\\BSON\\UTCDateTime)    schema. Class  Delegates the objects or arrays within the field to be mapped by another schema.     But you can easily create your own types. For example:  class MySchema extends Mongolid\\Schema\n{\n    ...\n\n    $fields = [\n        '_id' =  'sequence',\n        'name' =  'uppercaseString' // Will be processed by the method below\n    ];\n\n    public function uppercaseString(string $value) {\n        return strtoupper($value);\n    }\n}", 
            "title": "Default Schema $field types"
        }, 
        {
            "location": "/datamapper/#schema-definition-for-embeded-documents", 
            "text": "By using the  \"schema. Class \"  syntax you can create schemas and map Entities for embeded documents. For example, with the definition below:  class PostSchema extends Mongolid\\Schema\n{\n    public $entityClass = 'Post';\n    public $collection = 'posts';\n\n    $fields = [\n        '_id'      =  'objectId',\n        'title'    =  'string',\n        'body'     =  'string',\n        'comments' =  'schema.CommentSchema' // Embeds comments\n    ];\n}\n\nclass PostSchema extends Mongolid\\Schema\n{\n    public $entityClass = 'Comment';\n    public $collection = null; // Optional since all comments will be embedded\n\n    $fields = [\n        '_id'    =  'objectId',\n        'body'   =  'string',\n        'author' =  'string'\n    ];\n}  The MongoDB document  {\n    _id: ObjectId( 5099803df3f4948bd2f98391 ),\n    title:  Foo bar ,\n    body:  Lorem ipsum ,\n    comments: [\n        {\n            _id: ObjectId( 507f1f77bcf86cd799439011 ),\n            body:  Awesome! ,\n            author:  John Doe ,\n        },\n        {\n            _id: ObjectId( 507f191e810c19729de860ea ),\n            body:  Cool! ,\n            author:  Alan Turing ,\n        }\n    ]\n}  Will be mapped to the actual domain Entities:  $post = $manager- getMapper(Post::class)- first('5099803df3f4948bd2f98391');\n\nget_class($post) // Post\n\nget_class($post- comments[1]) // Comment;\n\n$post- comments[1]- author // Alan Turing\n\n// And if you are using Mongolid\\Model\\Relations trait in your entity ;)\n$post- comments()- sort(['author' =  1])- first()- name // Alan Turing", 
            "title": "Schema definition for embeded documents"
        }, 
        {
            "location": "/datamapper/#entity-helpers", 
            "text": "Mongolid provides some helpers for Domain Entities in the form of traits.", 
            "title": "Entity helpers"
        }, 
        {
            "location": "/datamapper/#attribute-trait", 
            "text": "The  Mongolid\\Model\\Attributes  trait adds attribute getters, setters and the  fill  method that can be used with  $fillable  and  $guarded  properties to make sure that only the correct attributes will be set.  By including this trait all the entity attributes will be isolated in the  $attributes  property of your entity and  mass assignment capabilities  will be available.  See  Mongolid\\Model\\Attributes  for more information.", 
            "title": "Attribute trait"
        }, 
        {
            "location": "/datamapper/#relations-trait", 
            "text": "The  Mongolid\\Model\\Relations  trait adds functionality for handling relations between entities. It will enable  embedsOne ,  embedsMany ,  referencesOne , referencesMany  methods and all the  relationship capabilities  in the entity.  Using relationship methods in DataMapper pattern  When using relationship methods ( embedsMany  for example) in DataMapper pattern, instead of referencing the  Entity  class you should reference the  Schema  class, for example:      ...\n    public function comments()\n    {\n        return $this- embedsMany('CommentSchema', 'comments');\n    }  In the example above Mongolid will use the  CommentSchema  to determine which Entity object should be used to map data of the  comments  field.  See  Mongolid\\Model\\Relations  for more information.", 
            "title": "Relations trait"
        }, 
        {
            "location": "/troubleshooting/", 
            "text": "Troubleshooting\n\n\nPHP Fatal error: Class \nMongoDB\\Client\n not found in \n\n\nThe \nMongoDB\\Client\n class is contained in the \nnew\n MongoDB driver\n for PHP. \nHere is an installation guide\n. The driver is a PHP extension written in C and maintained by \nMongoDB\n. Mongolid and most other MongoDB PHP libraries utilize it in order to be fast and reliable.\n\n\nClass \nMongoDB\\Client\n not found in \n in CLI persists even with MongoDB driver installed.\n\n\nMake sure that the \nphp.ini\n file used in the CLI environment includes the MongoDB extension. In some systems, the default PHP installation uses different \n.ini\n files for the web and CLI environments.\n\n\nRun \nphp -i | grep 'Configuration File'\n in a terminal to check the \n.ini\n that is being used.\n\n\nTo check if PHP in the CLI environment is importing the driver properly run \nphp -i | grep 'mongo'\n in your terminal. You should get output similar to:\n\n\n$ php -i | grep 'mongo'\nmongodb support =\n enabled\nmongodb version =\n 1.1.3", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/troubleshooting/#troubleshooting", 
            "text": "PHP Fatal error: Class  MongoDB\\Client  not found in   The  MongoDB\\Client  class is contained in the  new  MongoDB driver  for PHP.  Here is an installation guide . The driver is a PHP extension written in C and maintained by  MongoDB . Mongolid and most other MongoDB PHP libraries utilize it in order to be fast and reliable.  Class  MongoDB\\Client  not found in   in CLI persists even with MongoDB driver installed.  Make sure that the  php.ini  file used in the CLI environment includes the MongoDB extension. In some systems, the default PHP installation uses different  .ini  files for the web and CLI environments.  Run  php -i | grep 'Configuration File'  in a terminal to check the  .ini  that is being used.  To check if PHP in the CLI environment is importing the driver properly run  php -i | grep 'mongo'  in your terminal. You should get output similar to:  $ php -i | grep 'mongo'\nmongodb support =  enabled\nmongodb version =  1.1.3", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/info/", 
            "text": "License\n\n\nMongolid is free software distributed under the terms of the \nMIT license\n\n\nAdditional information\n\n\nMongolid was proudly built by the \nLeroy Merlin Brazil\n team. \nSee all the contributors\n.\n\n\nAny questions, feel free to contact us.\n\n\nAny issues, please \nreport here", 
            "title": "Additional information"
        }, 
        {
            "location": "/info/#license", 
            "text": "Mongolid is free software distributed under the terms of the  MIT license", 
            "title": "License"
        }, 
        {
            "location": "/info/#additional-information", 
            "text": "Mongolid was proudly built by the  Leroy Merlin Brazil  team.  See all the contributors .  Any questions, feel free to contact us.  Any issues, please  report here", 
            "title": "Additional information"
        }
    ]
}